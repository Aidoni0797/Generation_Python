Generation-34

Тема урока: вложенные списки

1. Создание вложенных списков
2. Считывание вложенных списков
3. Перебор элементов вложенных списков
4. Обработка вложенных списков
5. Вывод вложенных списков

Аннотация: Урок посвящен работе с вложенными списками.

Создание вложенных списков

Для создания вложенного списка можно использовать литеральную форму записи - перечисление элементов через запятую в квадратных скобках:
my_list = [[0],[1,2],[3,4,5]]

Иногда нужно создать вложенный список, заполненный по определенному правилу - шаблону. Например, список длиной n, содержащий списки длиной m, каждый из которых
заполнен нулями.

Рассмотрим несколько способов решения задачи.

Способ 1. Создадим пустой список, потом n раз добавим в него новый элемент - список длины m, составленный из нулей:

n,m = int(input()), int(input()) #считываем значения n и m
my_list = []

for _ in range(n):
  my_list.append([0]*m)

print(my_list)

Если ввести значения n=3, m=5, то результатом работы такого кода будет:
[[0,0,0,0,0], [0,0,0,0,0], [0,0,0,0,0]]

Если передать значения n=5, m=3, то результатом работы такого кода будет:
[[0,0,0], [0,0,0], [0,0,0], [0,0,0], [0,0,0]]

Способ 2. Сначала создадим список из n элементов (для начала просто из n нулей). Затем сделаем каждый элемент списка ссылкой на другой список из m элементов,
заполненный нулями:

n,m = int(input()), int(input()) #считываем значения n и m
my_list = [0]*n

for i in tange(n):
  my_list[i] = [0]*m

print(my_list)

Способ 3. Можно использовать генератор списка: создадим список из n элементов, каждый из которых будет списком, состоящих из m нулей:

n,m = int(input()), int(input()) #считываем значения n и m
my_list = [[0]*m for _ in range(n)]

print(my_list)

В этом случае каждый элемент создается независимо от остальных (заново конструируется вложенный список [0]*m для заполнения очередного элемента списка).

Обратите внимание, что очевидное решение, использующее операцию умножения списка на число (операция повторения), оказывается неверным:

n, m = int(input()), int(input()) #считываем значения n и m
my_list = [[0]*m]*n
print(my_list)

В этом дегко убедиться, если присвоить элементу my_list[0][0] любое значение, например, 17, а затем вывести список на печать:

n,m = int(input()), int(input())

my_list = [[0]*m]*n
my_list[0][0] = 17

print(my_list)

Если ввести значения n=5, m=3, то результатом работы такого кода будет:
[[17,0,0], [17,0,0], [17,0,0], [17,0,0], [17,0,0]]

То есть, изменив значение элемента списка my_list[0][0], мы также изменили значения элементов my_list[1][0], my_list[2][0], my_lst[3][0], my_list[4][0].

Причина такого поведения кроется в самой природе списков (тип list). В Python списки - ссылочный тип данных.
Конструкция [0]*m возвращает ссылку на список из m нулей

