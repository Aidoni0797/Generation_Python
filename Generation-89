Generation-89

Перебор элементов множества

Перебор элементов множества осуществляется точно так же, как и перебор элементов списка, то есть
с помощью цикла for. Для вывода элементов множества каждого на отдельной строке можно использовать
следующий код:

numbers = {0,1,1,2,3,3,3,5,6,7,7}

for num in numbers:
  print(num)

Приведенныйй выше код выводит (порядок элементов может отличаться):
0
1
2
3
5
6
7

Мы также можем использовать операцию распаковки множества.

Приведенный ниже код:
numbers = {0,1,1,2,3,3,3,5,6,7,7}
print(*numbers, sep='\n')

выводит (порядок элементов может отличаться):
0
1
2
3
5
6
7

Не стоит забывать, что множества - неупорядоченные коллекции, поэтому полагаться на порядок вывода элементов
не стоит. Если нужно гарантировать порядок вывода элементов (по возрастанию/убыванию), то
необходимо воспользовать встроенной функцией sorted().

Приведенный ниже код:
numbers = {0,1,1,2,3,3,3,5,6,7,7}
sorted_numbers = sorted(numbers)
print(*sorted_numbers, sep='\n')

будет гарантированно выводить элементы множества в порядке возрастания.

Обратите внимание на то, что функция sorted() возвращает отсортированный список, а не множество.
Не путайте встроенную функцию sorted() и списочный метод sort(). Множества не содержат метода sort().

Сравнение множеств
Множества можно сравнивать между собой. Равные множества имеют одинаковую длину и содержат равные
элементы. Для сравнения множеств используются операторы == и !=.

Приведенный ниже код:

myset1 = {1,2,3,3,3,3}
myset2 = {2,1,3}
myset3 = {1,2,3,4}

print(myset1 == myset2)
print(myset1 == myset3)
print(myset1 != myset3)

выводит:
True
False
True

Примечания

Примечание 1. Встроенная функция sorted() имеет опциональный параметр reverse. Если установить этот
параметр в значение True, произойдет сортировка по убыванию.

Приведенный ниже код:
numbers = {0,1,1,2,3,3,3,5,6,7,7}
sortnumbers = sorted(numbers, reverse = True)
print(*sortnumbers, sep='\n')
выводит:
7
6
5
3
2
1
0

Примечание 2. Код для работы с множествами нужно писать так, чтобы результат его выполнения не 
зависел от расположения элементов и был одинаковым при любом порядке обхода, последовательного
обращения ко всем элементам.

